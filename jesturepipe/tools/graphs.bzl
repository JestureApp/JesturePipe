load(
    "@mediapipe//mediapipe/framework/tool:mediapipe_graph.bzl",
    "mediapipe_binary_graph",
)

def jesture_binary_graph(name, short_name, graph = None, deps = None):
    """Creates a binary graph from a graph and a header file called name.h
    of the form
    ```
    const std::string {NAME}_CONFIG_CONTENTS = ...;
    ```

    Args:
        name (Label): The name of the rule to generate
        short_name (string):
        graph (Label, optional): The graph file. Defaults to None.
        deps ([Label], optional): Dependencies of the graph. Defaults to None.
    """

    if not graph:
        fail("No input graph file specified")

    if graph.endswith(".pbtxt"):
        bin_graph_output_name = graph.replace(".pbtxt", ".binarypb")
    else:
        bin_graph_output_name = graph + ".binarypb"

    mediapipe_binary_graph(
        name = name + "_gen",
        graph = graph,
        output_name = bin_graph_output_name,
        deps = deps,
    )

    encode_as_c_string = "@mediapipe//mediapipe/framework/tool:encode_as_c_string"

    # https://bazel.build/reference/be/general#genrule
    # echo "foo" > foo.txt
    native.genrule(
        name = name + "_header",
        srcs = [bin_graph_output_name],
        outs = [name + ".h"],
        tools = [encode_as_c_string],
        cmd = " ".join([
            "echo \"// Autogenerated config contents for %s\" > \"$@\"" % graph,
            "&& echo \"#ifndef __H_%s__\" >> \"$@\"" % short_name.upper(),
            "&& echo \"#define __H_%s__\" >> \"$@\"" % short_name.upper(),
            "&& echo \"#include <string>\" >> \"$@\"",
            "&& echo \"const std::string %s_CONFIG_CONTENTS = \" >> \"$@\"" % short_name.upper(),
            "&& $(location %s) \"$<\" >> \"$@\"" % encode_as_c_string,
            "&& echo \";\" >> \"$@\"",
            "&& echo \"#endif\" >> \"$@\"",
        ]),
    )

    native.cc_library(
        name = name,
        hdrs = [name + ".h"],
        deps = deps,
    )
